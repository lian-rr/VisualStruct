// this code was autogenerated from PJS

    var Graphic = (function() {
        function Graphic() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $this_1.transform = null;
            $this_1.bounds = null;
            $this_1.parent = null;
            $this_1.style = null;
            $this_1.info = null;
            $this_1.visible = true;

            function preDraw$0() {
                if ($this_1.style != null) {
                    $p.pushStyle();
                    $this_1.style.draw();
                }
                if ($this_1.transform != null) {
                    $p.pushMatrix();
                    $this_1.transform.draw();
                }
            }
            $p.addMethod($this_1, 'preDraw', preDraw$0, false);

            function draw$0() {

            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function postDraw$0() {
                if ($this_1.style != null) $p.popStyle();
                if ($this_1.transform != null) $p.popMatrix();
            }
            $p.addMethod($this_1, 'postDraw', postDraw$0, false);

            function contains$2(x, y) {
                return ($p.__contains($this_1.bounds, x, y));
            }
            $p.addMethod($this_1, 'contains', contains$2, false);

            function execute$1(call) {
                call.run($this_1.$self);
            }
            $p.addMethod($this_1, 'execute', execute$1, false);

            function updateBounds$1(b) {
                if ($this_1.bounds == null) $this_1.bounds = new Bounds(b);
                else $this_1.bounds.union(b);
                if ($this_1.parent != null) $this_1.parent.updateBounds(b);
            }
            $p.addMethod($this_1, 'updateBounds', updateBounds$1, false);

            function $constr() {
                $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Graphic;
    })();
    $p.Graphic = Graphic;
    var Shape = (function() {
        function Shape() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Graphic.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.params = null;
            $this_1.maxVertex = 20;
            $this_1.countVertex = 0;
            $this_1.modeShape = $p.CLOSE;

            function draw$0() {
                if (!$this_1.visible) return;
                $this_1.$self.preDraw();
                $p.beginShape();
                for (var i = 0; i < $this_1.countVertex; i++)
                $p.vertex($this_1.params[i * 2], $p.height - $this_1.params[i * 2 + 1]);
                $p.endShape($this_1.modeShape);
                $this_1.$self.postDraw();
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function updateBounds$0() {
                for (var i = 0; i < $this_1.countVertex; i++) {
                    if ($this_1.bounds == null) $this_1.bounds = new Bounds($this_1.params[i], $this_1.params[i * 2], $this_1.params[i], $this_1.params[i * 2]);
                    else $this_1.bounds.include($this_1.params[i], $this_1.params[i * 2]);
                }
            }
            $p.addMethod($this_1, 'updateBounds', updateBounds$0, false);

            function contains$2(x, y) {
                return ($p.__contains($this_1.bounds, x, y) && $this_1.$self.pointInPolygon(x, y));
            }
            $p.addMethod($this_1, 'contains', contains$2, false);

            function pointInPolygon$2(x, y) {
                var i = 0,
                    j = 0,
                    n = $this_1.countVertex;
                var c = false;

                for (i = 0, j = n - 1; i < n; j = i++) {
                    if ((($this_1.params[i * 2 + 1] > y) != ($this_1.params[j * 2 + 1] > y)) && (x < ($this_1.params[j * 2] - $this_1.params[i * 2]) * (y - $this_1.params[i * 2 + 1]) / ($this_1.params[j * 2 + 1] - $this_1.params[i * 2 + 1]) + $this_1.params[i * 2])) c = !c;
                }
                return c;
            }
            $p.addMethod($this_1, 'pointInPolygon', pointInPolygon$2, false);

            function distancePointLine$6(x, y, x1, y1, x2, y2) {
                var A = x - x1;
                var B = y - y1;
                var C = x2 - x1;
                var D = y2 - y1;

                var dot = A * C + B * D;
                var len_sq = C * C + D * D;
                var param = -1;
                if (len_sq != 0) param = dot / len_sq;

                var xx = 0,
                    yy = 0;

                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                var dx = x - xx;
                var dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            $p.addMethod($this_1, 'distancePointLine', distancePointLine$6, false);

            function distancePointPath$2(x, y) {
                var n = $this_1.countVertex;

                var distance = $p.MAX_FLOAT;
                var temp = 0;

                for (var i = 0; i < n - 1; i++) {
                    temp = $this_1.$self.distancePointLine(x, y, $this_1.params[i * 2], $this_1.params[i * 2 + 1], $this_1.params[i * 2 + 2], $this_1.params[i * 2 + 3]);
                    if (distance > temp) distance = temp;
                }
                return distance;
            }
            $p.addMethod($this_1, 'distancePointPath', distancePointPath$2, false);

            function $constr() {
                $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Shape, Graphic);
        Shape.$base = Graphic;
        return Shape;
    })();
    $p.Shape = Shape;
    var Group = (function() {
        function Group() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Graphic.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.children = null;
            $this_1.font = null;

            function addItem$1(g) {
                $this_1.children.add(g);
                g.parent = $this_1.$self;
                if (g.bounds != null) {
                    if ($this_1.bounds == null) $this_1.bounds = new Bounds(g.bounds);
                    else $this_1.$self.updateBounds(g.bounds);
                }
            }
            $p.addMethod($this_1, 'addItem', addItem$1, false);

            function empty$0() {
                $this_1.children.clear();
            }
            $p.addMethod($this_1, 'empty', empty$0, false);

            function draw$0() {
                if (!$this_1.visible) return;
                $this_1.$self.preDraw();
                if ($this_1.font != null) $this_1.font.draw();
                for (var i = 0; i < $this_1.children.size(); i++)($this_1.children.get(i)).draw();
                $this_1.$self.postDraw();
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function execute$1(call) {
                $super.execute(call);
                for (var i = 0; i < $this_1.children.size(); i++)($this_1.children.get(i)).execute(call);
            }
            $p.addMethod($this_1, 'execute', execute$1, false);

            function $constr_0() {
                $superCstr();

                $this_1.children = new $p.ArrayList();
            }

            function $constr() {
                if (arguments.length === 0) {
                    $constr_0.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Group, Graphic);
        Group.$base = Graphic;
        return Group;
    })();
    $p.Group = Group;
    var Path = (function() {
        function Path() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.maxVertex = 20;

            function addPart$1(seg) {
                if ($this_1.countVertex + seg.countVertex > $this_1.maxVertex) $this_1.$self.expand($this_1.countVertex + seg.countVertex);
                for (var i = 0; i < seg.countVertex * 2; i++)
                $this_1.params[($this_1.countVertex * 2) + i] = seg.params[i];

                $this_1.countVertex += seg.countVertex;
                $this_1.$self.updateBounds();
            }
            $p.addMethod($this_1, 'addPart', addPart$1, false);

            function expand$1(n) {
                $this_1.maxVertex = n;
                var temp = $p.createJavaArray('float', [$this_1.maxVertex * 2]);
                for (var i = 0; i < $this_1.countVertex * 2; i++)
                temp[i] = $this_1.params[i];
                $this_1.params = temp;
            }
            $p.addMethod($this_1, 'expand', expand$1, false);

            function $constr_0() {
                $superCstr();

                $this_1.params = $p.createJavaArray('float', [$this_1.maxVertex * 2]);
            }

            function $constr() {
                if (arguments.length === 0) {
                    $constr_0.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Path, Shape);
        Path.$base = Shape;
        return Path;
    })();
    $p.Path = Path;
    var Transform = (function() {
        function Transform() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $this_1.Method = (function() {
                function Method() {
                    var $this_2 = this;

                    function $superCstr() {
                        $p.extendClassChain($this_2)
                    }
                    $this_2.type = 0;
                    $this_2.x = 0;
                    $this_2.y = 0;

                    function $constr_3(t, a, b) {
                        $superCstr();

                        $this_2.type = t;
                        $this_2.x = a;
                        $this_2.y = b;
                    }

                    function $constr() {
                        if (arguments.length === 3) {
                            $constr_3.apply($this_2, arguments);
                        } else $superCstr();
                    }
                    $constr.apply(null, arguments);
                }
                return Method;
            })();
            $this_1.TRANSLATE = 0;
            $this_1.SCALE = 1;
            $this_1.ROTATE = 2;
            $this_1.trans = null;

            function translation$2(x, y) {
                $this_1.trans.add(new $this_1.Method($this_1.TRANSLATE, x, y));
            }
            $p.addMethod($this_1, 'translation', translation$2, false);

            function scalation$2(x, y) {
                $this_1.trans.add(new $this_1.Method($this_1.SCALE, x, y));
            }
            $p.addMethod($this_1, 'scalation', scalation$2, false);

            function rotation$1(x) {
                $this_1.trans.add(new $this_1.Method($this_1.ROTATE, x, 0));
            }
            $p.addMethod($this_1, 'rotation', rotation$1, false);

            function reset$0() {
                $this_1.trans.clear();
            }
            $p.addMethod($this_1, 'reset', reset$0, false);

            function draw$0() {
                for (var i = 0; i < $this_1.trans.size(); i++) {
                    var m = $this_1.trans.get(i);
                    switch (m.type) {
                    case $this_1.TRANSLATE:
                        $p.translate(m.x, -m.y);
                        break;
                    case $this_1.SCALE:
                        $p.translate(0, $p.height);
                        $p.scale(m.x, m.y);
                        $p.translate(0, -$p.height);
                        break;
                    case $this_1.ROTATE:
                        $p.translate(0, $p.height);
                        $p.rotate($p.radians(m.x));
                        $p.translate(0, -$p.height);
                        break;
                    }
                }
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function $constr_0() {
                $superCstr();

                $this_1.trans = new $p.ArrayList();
            }

            function $constr() {
                if (arguments.length === 0) {
                    $constr_0.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Transform;
    })();
    $p.Transform = Transform;
    var Arc = (function() {
        function Arc() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $p.defineProperty($this_1, 'PIE', {
                get: function() {
                    return Arc.PIE
                },
                set: function(val) {
                    Arc.PIE = val
                }
            });
            $p.defineProperty($this_1, 'CHORD', {
                get: function() {
                    return Arc.CHORD
                },
                set: function(val) {
                    Arc.CHORD = val
                }
            });

            function $constr_6(x, y, w, h, s, e) {
                $constr(x, y, w, h, s, e, Arc.PIE);
            }

            function $constr_7(cx, cy, w, h, s, e, m) {
                $constr(cx, cy, w, h, s, e, m, 90);
            }

            function $constr_8(cx, cy, w, h, start, end, mode, n) {
                $superCstr();

                $this_1.params = $p.createJavaArray('float', [n * 2]);
                var parts = n;
                var part = 2.0 * 3.1415926 / parts;
                var t = 0;

                if (mode == Arc.PIE) {
                    $this_1.params[t * 2] = cx;
                    $this_1.params[t * 2 + 1] = cy;
                    t++;
                }

                for (var theta = start; theta < end; theta += part, t++) {
                    var x = w / 2 * Math.cos(theta);
                    var y = h / 2 * Math.sin(theta);
                    $this_1.params[t * 2] = (x + cx);
                    $this_1.params[t * 2 + 1] = (y + cy);
                }
                $this_1.countVertex = t;
                if (mode == Arc.CHORD || mode == Arc.PIE) $this_1.modeShape = $p.CLOSE;
                else $this_1.modeShape = $p.OPEN;
                $this_1.$self.updateBounds();
            }

            function $constr() {
                if (arguments.length === 6) {
                    $constr_6.apply($this_1, arguments);
                } else if (arguments.length === 7) {
                    $constr_7.apply($this_1, arguments);
                } else if (arguments.length === 8) {
                    $constr_8.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Arc, Shape);
        Arc.PIE = 0;
        Arc.CHORD = 0;
        Arc.$base = Shape;
        return Arc;
    })();
    $p.Arc = Arc;
    var Bezier = (function() {
        function Bezier() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function $constr_8(x1, y1, x2, y2, x3, y3, x4, y4) {
                $constr(x1, y1, x2, y2, x3, y3, x4, y4, 10);
            }

            function $constr_9(x1, y1, x2, y2, x3, y3, x4, y4, n) {
                $superCstr();

                $this_1.modeShape = $p.OPEN;
                $this_1.params = $p.createJavaArray('float', [(n + 1) * 2]);

                for (var i = 0; i <= n; ++i) {
                    var t = i / n;
                    var a = Math.pow((1.0 - t), 3.0);
                    var b = 3.0 * t * Math.pow((1.0 - t), 2.0);
                    var c = 3.0 * Math.pow(t, 2.0) * (1.0 - t);
                    var d = Math.pow(t, 3.0);
                    var x = a * x1 + b * x2 + c * x3 + d * x4;
                    var y = a * y1 + b * y2 + c * y3 + d * y4;
                    $this_1.params[i * 2] = x;
                    $this_1.params[i * 2 + 1] = y;
                }

                $this_1.countVertex = $this_1.params.length / 2;
                $this_1.$self.updateBounds();
            }

            function $constr() {
                if (arguments.length === 8) {
                    $constr_8.apply($this_1, arguments);
                } else if (arguments.length === 9) {
                    $constr_9.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Bezier, Shape);
        Bezier.$base = Shape;
        return Bezier;
    })();
    $p.Bezier = Bezier;
    var Bounds = (function() {
        function Bounds() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $this_1.xMin = 0;
            $this_1.yMin = 0;
            $this_1.xMax = 0;
            $this_1.yMax = 0;

            function width$0() {
                return $this_1.xMax - $this_1.xMin;
            }
            $p.addMethod($this_1, 'width', width$0, false);

            function height$0() {
                return $this_1.yMax - $this_1.yMin;
            }
            $p.addMethod($this_1, 'height', height$0, false);

            function include$2(x, y) {
                if (x < $this_1.xMin) $this_1.xMin = x;
                if (x > $this_1.xMax) $this_1.xMax = x;
                if (y < $this_1.yMin) $this_1.yMin = y;
                if (y > $this_1.yMax) $this_1.yMax = y;
            }
            $p.addMethod($this_1, 'include', include$2, false);

            function union$1(b) {
                $this_1.$self.include(b.xMin, b.yMin);
                $this_1.$self.include(b.xMax, b.yMax);
            }
            $p.addMethod($this_1, 'union', union$1, false);

            function contains$2(x, y) {
                return ($this_1.xMin < x) && (x < $this_1.xMax) && ($this_1.yMin < y) && (y < $this_1.yMax);
            }
            $p.addMethod($this_1, 'contains', contains$2, false);

            function $constr_4(a, b, c, d) {
                $superCstr();

                $this_1.xMin = a;
                $this_1.yMin = b;
                $this_1.xMax = c;
                $this_1.yMax = d;
            }

            function $constr_1(b) {
                $superCstr();

                $this_1.xMin = b.xMin;
                $this_1.yMin = b.yMin;
                $this_1.xMax = b.xMax;
                $this_1.yMax = b.yMax;
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else if (arguments.length === 1) {
                    $constr_1.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Bounds;
    })();
    $p.Bounds = Bounds;
    var Callback = (function() {
        function Callback() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }

            function run$1(g) {
                $p.println("picked: " + g.bounds.xMin + "," + g.bounds.yMin);
            }
            $p.addMethod($this_1, 'run', run$1, false);

            function $constr() {
                $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Callback;
    })();
    $p.Callback = Callback;
    var Curve = (function() {
        function Curve() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function $constr_8(x0, y0, x1, y1, x2, y2, x3, y3) {
                $constr(x0, y0, x1, y1, x2, y2, x3, y3, 10);
            }

            function $constr_9(x0, y0, x1, y1, x2, y2, x3, y3, n) {
                $superCstr();

                $this_1.modeShape = $p.OPEN;
                $this_1.params = $p.createJavaArray('float', [(n + 1) * 2]);

                var aX = (2.0 * x1);
                var aY = (2.0 * y1);
                var bX = (-x0 + x2);
                var bY = (-y0 + y2);
                var cX = (2.0 * x0 - 5.0 * x1 + 4 * x2 - x3);
                var cY = (2.0 * y0 - 5.0 * y1 + 4 * y2 - y3);
                var dX = (-x0 + 3.0 * x1 - 3.0 * x2 + x3);
                var dY = (-y0 + 3.0 * y1 - 3.0 * y2 + y3);

                for (var i = 0; i <= n; ++i) {
                    var t = i / n;
                    var t2 = t * t;
                    var t3 = t2 * t;
                    var x = 0.5 * (aX + bX * t + cX * t2 + dX * t3);
                    var y = 0.5 * (aY + bY * t + cY * t2 + dY * t3);
                    $this_1.params[i * 2] = x;
                    $this_1.params[i * 2 + 1] = y;
                }

                $this_1.countVertex = $this_1.params.length / 2;
                $this_1.$self.updateBounds();
            }

            function $constr() {
                if (arguments.length === 8) {
                    $constr_8.apply($this_1, arguments);
                } else if (arguments.length === 9) {
                    $constr_9.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Curve, Shape);
        Curve.$base = Shape;
        return Curve;
    })();
    $p.Curve = Curve;
    var Ellipse = (function() {
        function Ellipse() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function _Ellipse$5(cx, cy, w, h, n) {
                $this_1.params = $p.createJavaArray('float', [n * 2]);
                var parts = n;
                var t = 0;
                for (t = 0; t < parts; t++) {
                    var theta = 2.0 * 3.1415926 * t / parts;
                    var x = cx + w / 2 * Math.cos(theta);
                    var y = cy + h / 2 * Math.sin(theta);
                    $this_1.params[t * 2] = (x);
                    $this_1.params[t * 2 + 1] = (y);
                }
                $this_1.countVertex = $this_1.params.length / 2;
                $this_1.$self.updateBounds();
            }
            $p.addMethod($this_1, '_Ellipse', _Ellipse$5, false);

            function $constr_4(x, y, a, b) {
                $constr(x, y, a, b, $p.CENTER);
            }

            function $constr_5(x, y, a, b, m) {
                $constr(x, y, a, b, m, 90);
            }

            function $constr_6(x, y, a, b, m, n) {
                $superCstr();

                switch (m) {
                case $p.CORNERS:
                    $this_1.$self._Ellipse((x + a) / 2, (y + b) / 2, a - x, b - y, n);
                    break;
                case $p.CENTER:
                    $this_1.$self._Ellipse(x, y, a, b, n);
                    break;
                case $p.RADIUS:
                    $this_1.$self._Ellipse(x, y, a * 2, b * 2, n);
                    break;
                case $p.CORNER:
                    $this_1.$self._Ellipse(x + a / 2, y + b / 2, a, b, n);
                    break;
                }
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else if (arguments.length === 5) {
                    $constr_5.apply($this_1, arguments);
                } else if (arguments.length === 6) {
                    $constr_6.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Ellipse, Shape);
        Ellipse.$base = Shape;
        return Ellipse;
    })();
    $p.Ellipse = Ellipse;
    var Font = (function() {
        function Font() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $this_1.font = null;
            $this_1.fontFamily = null;
            $this_1.fontSize = 0;

            function draw$0() {
                $p.textSize($this_1.fontSize);
                if (($this_1.font == null) && ($this_1.fontFamily != null)) $this_1.font = $p.loadFont($this_1.fontFamily);
                if ($this_1.fontFamily != null) $p.textFont($this_1.font);
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function $constr_1(a) {
                $superCstr();

                $this_1.fontSize = a;
            }

            function $constr_2(a, b) {
                $superCstr();

                $this_1.fontSize = a;
                $this_1.fontFamily = b;
            }

            function $constr() {
                if (arguments.length === 1) {
                    $constr_1.apply($this_1, arguments);
                } else if (arguments.length === 2) {
                    $constr_2.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Font;
    })();
    $p.Font = Font;
    var Info = (function() {
        function Info() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }

            function $constr() {
                $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Info;
    })();
    $p.Info = Info;
    var Layer = (function() {
        function Layer() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Group.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.shapes = null;

            function loadBNA$1(filename) {
                var shape = null;
                var lines = $p.loadStrings(filename);
                var x = 0,
                    y = 0;
                var n = 0;
                for (var i = 0; i < lines.length; i++) {
                    var list = $p.splitTokens(lines[i], ",");
                    if (n > 0) {
                        x = $p.parseFloat(list[0]);
                        y = $p.parseFloat(list[1]);
                        n--;
                    } else if (list[0].charAt(0) == (new $p.Character('"'))) {
                        var c = $p.parseInt(list[list.length - 1]);
                        n = $p.abs(c);
                        $this_1.shapes.add(shape);
                    }
                }
            }
            $p.addMethod($this_1, 'loadBNA', loadBNA$1, false);

            function $constr() {
                $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Layer, Group);
        Layer.$base = Group;
        return Layer;
    })();
    $p.Layer = Layer;
    var Line = (function() {
        function Line() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function $constr_4(a, b, c, d) {
                $superCstr();

                $this_1.params = [a, b, c, d];
                $this_1.bounds = new Bounds(a, b, c, d);
                $this_1.maxVertex = $this_1.countVertex = $this_1.params.length / 2;
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Line, Shape);
        Line.$base = Shape;
        return Line;
    })();
    $p.Line = Line;
    var Polygon = (function() {
        function Polygon() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function $constr_1(a) {
                $superCstr();

                $this_1.params = a;
                $this_1.maxVertex = $this_1.countVertex = $this_1.params.length / 2;
                $this_1.$self.updateBounds();
            }

            function $constr() {
                if (arguments.length === 1) {
                    $constr_1.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Polygon, Shape);
        Polygon.$base = Shape;
        return Polygon;
    })();
    $p.Polygon = Polygon;
    var Rect = (function() {
        function Rect() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function _Rect$4(a, b, c, d) {
                $this_1.params = [a, b, a, b + d, a + c, b + d, a + c, b];
                $this_1.bounds = new Bounds(a, b, a + c, b + d);
                $this_1.countVertex = $this_1.params.length / 2;
            }
            $p.addMethod($this_1, '_Rect', _Rect$4, false);

            function $constr_4(x, y, a, b) {
                $constr(x, y, a, b, $p.CORNER);
            }

            function $constr_5(x, y, a, b, m) {
                $superCstr();

                switch (m) {
                case $p.CORNERS:
                    $this_1.$self._Rect((x + a) / 2, (y + b) / 2, a - x, b - y);
                    break;
                case $p.CORNER:
                    $this_1.$self._Rect(x, y, a, b);
                    break;
                case $p.RADIUS:
                    $this_1.$self._Rect(x, y, a * 2, b * 2);
                    break;
                case $p.CENTER:
                    $this_1.$self._Rect(x + a / 2, y + b / 2, a, b);
                    break;
                }
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else if (arguments.length === 5) {
                    $constr_5.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Rect, Shape);
        Rect.$base = Shape;
        return Rect;
    })();
    $p.Rect = Rect;
    var RectAxis = (function() {
        function RectAxis() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Group.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.x = 0;
            $this_1.y = 0;
            $this_1.extent = 100;
            $this_1.position = $p.BOTTOM;
            $this_1.minValue = 0;
            $this_1.maxValue = 10;
            $this_1.tickInc = 20;
            $this_1.tickLen = 10;
            $this_1.tickStyle = null;
            $this_1.tickEnable = true;
            $this_1.labelEnable = true;
            $this_1.labelColor = 0;
            $this_1.labelSize = 10;
            $this_1.items = null;
            $this_1.ticks = new Group();
            $this_1.labels = new Group();
            $this_1.baseline = null;

            function update$0() {
                if ($this_1.position == $p.BOTTOM) $this_1.baseline = new Line($this_1.x, $this_1.y, $this_1.x + $this_1.extent, $this_1.y);
                else if ($this_1.position == $p.LEFT) $this_1.baseline = new Line($this_1.x, $this_1.y, $this_1.x, $this_1.y + $this_1.extent);
                if ($this_1.tickEnable && $this_1.items != null) $this_1.$self.makeTicksCat();
                if ($this_1.tickEnable && $this_1.items == null) $this_1.$self.makeTicksNum();
                if ($this_1.labelEnable && $this_1.items != null) $this_1.$self.makeLabelsCat();
                if ($this_1.labelEnable && $this_1.items == null) $this_1.$self.makeLabelsNum();
                $this_1.$self.addItem($this_1.ticks);
                $this_1.$self.addItem($this_1.labels);
                $this_1.$self.addItem($this_1.baseline);
            }
            $p.addMethod($this_1, 'update', update$0, false);

            function makeTicksNum$0() {
                var axisMode = 1;
                if ($this_1.position == $p.LEFT) axisMode = -1;

                for (var v = $this_1.minValue; v <= $this_1.maxValue; v += $this_1.tickInc) {
                    var pos = $p.__int_cast($p.map(v, $this_1.minValue, $this_1.maxValue, 0, $this_1.extent));
                    if ($this_1.position == $p.BOTTOM) $this_1.ticks.addItem(new Line($this_1.x + pos, $this_1.y, $this_1.x + pos, $this_1.y - $this_1.tickLen * axisMode));
                    else $this_1.ticks.addItem(new Line($this_1.x, $this_1.y + pos, $this_1.x + $this_1.tickLen * axisMode, $this_1.y + pos));
                }
            }
            $p.addMethod($this_1, 'makeTicksNum', makeTicksNum$0, false);

            function makeTicksCat$0() {
                var axisMode = 1;
                if ($this_1.position == $p.LEFT) axisMode = -1;

                var inc = $p.parseInt($this_1.extent / $this_1.items.length);

                for (var pos = 0; pos <= $this_1.extent; pos += inc) {
                    if ($this_1.position == $p.BOTTOM) $this_1.ticks.addItem(new Line($this_1.x + pos, $this_1.y, $this_1.x + pos, $this_1.y - $this_1.tickLen * axisMode));
                    else $this_1.ticks.addItem(new Line($this_1.x, $this_1.y + pos, $this_1.x + $this_1.tickLen * axisMode, $this_1.y + pos));
                }
            }
            $p.addMethod($this_1, 'makeTicksCat', makeTicksCat$0, false);

            function makeLabelsNum$0() {
                $this_1.labels.font = new Font($this_1.labelSize, null);
                $this_1.labels.style = new Style(0, $this_1.labelColor, 1);

                for (var v = $this_1.minValue; v <= $this_1.maxValue; v += $this_1.tickInc) {
                    var pos = $p.__int_cast($p.map(v, $this_1.minValue, $this_1.maxValue, 0, $this_1.extent));
                    var label = $p.str(v);
                    var strWidth = $p.__int_cast((label.length * $this_1.labelSize * 0.7));
                    if ($this_1.position == $p.BOTTOM) $this_1.labels.addItem(new Text(label, $this_1.x + pos - ($this_1.tickInc / 2), $this_1.y - ($this_1.tickLen + $this_1.labelSize + 5)));
                    else $this_1.labels.addItem(new Text(label, $this_1.x - $this_1.tickLen - strWidth, $this_1.y + pos - 5));
                }
            }
            $p.addMethod($this_1, 'makeLabelsNum', makeLabelsNum$0, false);

            function makeLabelsCat$0() {
                $this_1.labels.font = new Font($this_1.labelSize, null);
                $this_1.labels.style = new Style(0, $this_1.labelColor, 1);

                var inc = $p.parseInt($this_1.extent / $this_1.items.length);

                for (var pos = 0, n = 0; n < $this_1.items.length; pos += inc, n++) {
                    var label = $this_1.items[n];
                    var strWidth = $p.__int_cast((label.length * $this_1.labelSize * 0.7));
                    if ($this_1.position == $p.BOTTOM) $this_1.labels.addItem(new Text(label, $this_1.x + pos + (inc - strWidth) / 2, $this_1.y - ($this_1.tickLen + $this_1.labelSize + 5)));
                    else $this_1.labels.addItem(new Text(label, $this_1.x - $this_1.tickLen - strWidth, $this_1.y + pos + (inc / 2) - 5));
                }
            }
            $p.addMethod($this_1, 'makeLabelsCat', makeLabelsCat$0, false);

            function $constr_4(_x, _y, _extent, _position) {
                $superCstr();

                $this_1.x = _x;
                $this_1.y = _y;
                $this_1.extent = _extent;
                $this_1.position = _position;
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(RectAxis, Group);
        RectAxis.$base = Group;
        return RectAxis;
    })();
    $p.RectAxis = RectAxis;
    var RoundedRect = (function() {
        function RoundedRect() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Path.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }

            function $constr_5(x, y, w, h, r) {
                $constr(x, y, w, h, r, r);
            }

            function $constr_6(x, y, w, h, r1, r2) {
                $superCstr();

                $this_1.$self.addPart(new Arc(x + w - r1 / 2, y + h - r2 / 2, r1, r2, 0, $p.HALF_PI, $p.OPEN));
                $this_1.$self.addPart(new Line(x + w - r1, y + h, x + r1, y + h));
                $this_1.$self.addPart(new Arc(x + r1 / 2, y + h - r2 / 2, r1, r2, $p.HALF_PI, $p.PI, $p.OPEN));
                $this_1.$self.addPart(new Line(x, y + h - r2, x, y + r2 / 2));
                $this_1.$self.addPart(new Arc(x + r1 / 2, y + r2 / 2, r1, r2, $p.PI, $p.PI + $p.HALF_PI, $p.OPEN));
                $this_1.$self.addPart(new Line(x + r1 / 2, y, x + w - r1 / 2, y));
                $this_1.$self.addPart(new Arc(x + w - r1 / 2, y + r2 / 2, r1, r2, $p.PI + $p.HALF_PI, $p.TWO_PI, $p.OPEN));
            }

            function $constr() {
                if (arguments.length === 5) {
                    $constr_5.apply($this_1, arguments);
                } else if (arguments.length === 6) {
                    $constr_6.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(RoundedRect, Path);
        RoundedRect.$base = Path;
        return RoundedRect;
    })();
    $p.RoundedRect = RoundedRect;
    var Style = (function() {
        function Style() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $p.defineProperty($this_1, 'NONE', {
                get: function() {
                    return Style.NONE
                },
                set: function(val) {
                    Style.NONE = val
                }
            });
            $this_1.strokeColor = 0x00000000;
            $this_1.fillColor = 0x00000000;
            $this_1.strokeWidth = 0;

            function draw$0() {
                if ($this_1.strokeColor == Style.NONE) $p.noStroke();
                else $p.stroke($this_1.strokeColor);
                if ($this_1.fillColor == Style.NONE) $p.noFill();
                else $p.fill($this_1.fillColor);
                if ($this_1.strokeWidth > 0) {
                    System.strokeWidth *= $this_1.strokeWidth;
                    $p.strokeWeight(System.strokeWidth);
                }
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function $constr_1(a) {
                $superCstr();

                $this_1.strokeColor = a;
            }

            function $constr_2(a, b) {
                $superCstr();

                $this_1.strokeColor = a;
                $this_1.fillColor = b;
            }

            function $constr_3(a, b, c) {
                $superCstr();

                $this_1.strokeColor = a;
                $this_1.fillColor = b;
                $this_1.strokeWidth = c;
            }

            function $constr() {
                if (arguments.length === 1) {
                    $constr_1.apply($this_1, arguments);
                } else if (arguments.length === 2) {
                    $constr_2.apply($this_1, arguments);
                } else if (arguments.length === 3) {
                    $constr_3.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        Style.NONE = -1;
        return Style;
    })();
    $p.Style = Style;
    var System = (function() {
        function System() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $p.defineProperty($this_1, 'strokeWidth', {
                get: function() {
                    return System.strokeWidth
                },
                set: function(val) {
                    System.strokeWidth = val
                }
            });
            $p.defineProperty($this_1, 'xCoord', {
                get: function() {
                    return System.xCoord
                },
                set: function(val) {
                    System.xCoord = val
                }
            });
            $p.defineProperty($this_1, 'yCoord', {
                get: function() {
                    return System.yCoord
                },
                set: function(val) {
                    System.yCoord = val
                }
            });
            $p.addMethod($this_1, 'reset', reset$0, false);

            function $constr() {
                $superCstr();
            }
            $constr.apply(null, arguments);
        }
        System.strokeWidth = 1;
        System.xCoord = 0;
        System.yCoord = 0;

        function reset$0() {
            System.strokeWidth = 1;
        }
        $p.addMethod(System, 'reset', reset$0, false);
        return System;
    })();
    $p.System = System;
    var Text = (function() {
        function Text() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Shape.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.str = null;
            $this_1.font = null;

            function draw$0() {
                $this_1.$self.preDraw();
                if ($this_1.font != null) $this_1.font.draw();
                $p.text($this_1.str, $this_1.params[0], $p.height - $this_1.params[1]);
                $this_1.$self.postDraw();
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function $constr_3(_str, a, b) {
                $superCstr();

                $this_1.params = [a, b];
                $this_1.bounds = new Bounds(a, b - 20, a + 20, b + 20);
                $this_1.maxVertex = $this_1.countVertex = $this_1.params.length / 2;
                $this_1.str = _str;
            }

            function $constr() {
                if (arguments.length === 3) {
                    $constr_3.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(Text, Shape);
        Text.$base = Shape;
        return Text;
    })();
    $p.Text = Text;
    var View = (function() {
        function View() {
            var $this_1 = this;
            var $super = {
                $upcast: $this_1
            };

            function $superCstr() {
                Group.apply($super, arguments);
                if (! ('$self' in $super)) $p.extendClassChain($super)
            }
            $this_1.extent = null;
            $this_1.dimensions = null;
            $this_1.scale = 1;
            $this_1.xCenter = 0;
            $this_1.yCenter = 0;

            function draw$0() {
                System.reset();
                $p.rect($this_1.dimensions.xMin - 1, $this_1.dimensions.yMin - 1, $this_1.dimensions.width() + 1, $this_1.dimensions.height() + 1);
                Processing.instances[0].externals.context.clip();
                $super.draw();
            }
            $p.addMethod($this_1, 'draw', draw$0, false);

            function zoomToFullExtent$0() {
                $this_1.extent = $this_1.bounds;
                $this_1.$self._zoomToExtent();
            }
            $p.addMethod($this_1, 'zoomToFullExtent', zoomToFullExtent$0, false);

            function zoomToExtent$1(extnt) {
                $this_1.extent = extnt;
                $this_1.$self._zoomToExtent();
            }
            $p.addMethod($this_1, 'zoomToExtent', zoomToExtent$1, false);

            function _zoomToExtent$0() {
                $this_1.scale = $p.min($this_1.dimensions.width() / $this_1.extent.width(), $this_1.dimensions.height() / $this_1.extent.height());
                $this_1.xCenter = $this_1.dimensions.width() / 2 + $this_1.dimensions.xMin;
                $this_1.yCenter = $this_1.dimensions.height() / 2 + $this_1.dimensions.yMin;
                $this_1.$self._zoom();
            }
            $p.addMethod($this_1, '_zoomToExtent', _zoomToExtent$0, false);

            function _zoom$0() {
                $this_1.transform.reset();
                $this_1.transform.translation($this_1.xCenter, $this_1.yCenter);
                $this_1.transform.scalation($this_1.scale, $this_1.scale);
                $this_1.transform.translation(-($this_1.extent.xMin + $this_1.extent.width() / 2), -($this_1.extent.yMin + $this_1.extent.height() / 2));
                $this_1.style.strokeWidth = (1 / $this_1.scale);
            }
            $p.addMethod($this_1, '_zoom', _zoom$0, false);

            function zoomToScale$1(scl) {
                $this_1.scale *= scl;
                $this_1.$self._zoom();
            }
            $p.addMethod($this_1, 'zoomToScale', zoomToScale$1, false);

            function translateCenter$2(x, y) {
                $this_1.extent.xMin += x / $this_1.scale;
                $this_1.extent.xMax += x / $this_1.scale;
                $this_1.extent.yMin -= y / $this_1.scale;
                $this_1.extent.yMax -= y / $this_1.scale;
                $this_1.$self._zoom();
            }
            $p.addMethod($this_1, 'translateCenter', translateCenter$2, false);

            function pick$3(x, y, call) {
                System.xCoord = (x - $this_1.xCenter) / $this_1.scale + $this_1.extent.xMin + $this_1.extent.width() / 2;
                System.yCoord = (y - $this_1.yCenter) / $this_1.scale + $this_1.extent.yMin + $this_1.extent.height() / 2;
                $this_1.$self.execute(call);
            }
            $p.addMethod($this_1, 'pick', pick$3, false);

            function $constr_4(a, b, c, d) {
                $superCstr();

                $this_1.dimensions = new Bounds(a, b, a + c, b + d);
                $this_1.transform = new Transform();
                $this_1.style = new Style(0, 255, 1);
            }

            function $constr_0() {
                $superCstr();

                $this_1.transform = new Transform();
                $this_1.style = new Style(0, 255, 1);
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else if (arguments.length === 0) {
                    $constr_0.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        $p.extendStaticMembers(View, Group);
        View.$base = Group;
        return View;
    })();
    $p.View = View;